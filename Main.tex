\documentclass[t]{beamer}
\usepackage[portuges]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[scaled]{helvet}
\usepackage{svg}
\renewcommand{\familydefault}{\sfdefault}

%%%
%%% Define cores
%%%
\definecolor{cinza}{HTML}{75818B}

%%%
%%% Remove a barra de navegação do Beamer
%%%
\setbeamertemplate{navigation symbols}{}

%%%
%%% Margem dos slides
%%%
\setbeamersize{text margin left=10mm,text margin right=5mm} 

%%%
%%% Redefine a fonte do título dos slides
%%%
\setbeamercolor{frametitle}{fg=cinza}
\setbeamerfont{frametitle}{series=\bfseries}
\setbeamerfont{frametitle}{size=\Large}

%%%
%%% Ajusta a posição do título dos slides e início do texto
%%%
\addtobeamertemplate{frametitle}{\vspace*{2mm}}{\vspace*{5mm}}

%%%
%%% Adiciona paginação nos slides
%%%
%%% Caso não queira, basta comentar este bloco inteiro
%%% para ocultar a paginação
%%%
\addtobeamertemplate{navigation symbols}{}{
\usebeamerfont{footline}
\usebeamercolor[fg]{footline}
}
\setbeamercolor{footline}{fg=cinza}
\setbeamerfont{footline}{series=\bfseries}
\setbeamerfont{footline}{size=\tiny}
\setbeamertemplate{footline}{
\usebeamerfont{page number in head}
\usebeamercolor[fg]{page number in head}
\hspace{5mm}
\insertframenumber/\inserttotalframenumber
\vspace{5mm}
}

%%%
%%% Redefine símbolo padrão do itemize
%%%
\setbeamertemplate{itemize items}[default]

%%%
%%% Insere numeração nas figuras
%%%
\setbeamertemplate{caption}[numbered]

%%%
%%% Imagem de fundo a ser usada em todos os slides (exceto
%%% no primeiro e no último)
%%%
\usebackgroundtemplate
{
\includegraphics[width=\paperwidth,height=\paperheight]{Imagens/fundo.png}
}

%%%
%%% Adiciona slide de "Estrutura"
%%%
\AtBeginSection[]{\frame{\frametitle{Estrutura}\tableofcontents
[current]}}

%%%
%%% Define fontes e cores do slide de "Estrutura"
%%%
\setbeamerfont{section in toc}{series=\bfseries}
\setbeamercolor{section in toc}{fg=gray}
\setbeamerfont{section in toc shaded}{series=\mdseries}
\setbeamercolor{section in toc shaded}{fg=gray!01}
\setbeamercolor{subsection in toc}{fg=cinza}
\setbeamercolor{subsection in toc shaded}{fg=gray!60}
\setbeamercolor{subsubsection in toc}{fg=cinza}
\setbeamercolor{subsubsection in toc shaded}{fg=gray!60}

\mode<presentation>
%%%
%%% Início
%%%
\begin{document}

%%%
%%% Slide da capa
%%%
{
\usebackgroundtemplate{\includegraphics[width=\paperwidth]{Imagens/capa.png}}
\begin{frame}[plain]
\vspace{18mm}
%%%
%%% Título da Apresentação
%%%
\begin{flushright}
\textcolor{cinza}{\textbf{\large{
Provas de Conhecimento Zero: Um Estudo sobre zk-SNARKs e sua Aplicação em Sistemas de Autenticação
}}}
\end{flushright}

\vspace{-6mm}
%%%
%%% Nome do autor
%%%
\begin{flushright}
\textcolor{cinza}{\textbf{\scriptsize{
Alex Davis Neuwiem da Silva
}}}
\end{flushright}

\vspace{-7mm}
%%%
%%% Formação | Departamento | Centro
%%%
\begin{flushright}
\textcolor{cinza}{\scriptsize{
Ciências da Computação | INE | CTC
}}
\end{flushright}


\end{frame}
}

%%%
%%% Demais slides (exceto o slide final)
%%%

\begin{frame}{Introdução}
\begin{columns}[c]
\begin{column}{.5\textwidth}
  \textbf{1. Estudo Teórico}
  \begin{itemize}
    \item Realizar uma análise aprofundada dos principais protocolos zk-SNARKs.
    \item Foco em \textbf{Pinocchio} e \textbf{Groth16}.
  \end{itemize}
\end{column}
\begin{column}{.5\textwidth}
\textbf{2. Aplicação Prática}
  \begin{itemize}
    \item Desenvolver de um sistema de autenticação biométrica facial que preserva a privacidade.
    \item Utiliza \textbf{Groth16}.
  \end{itemize}
\end{column}
\end{columns}
\end{frame}

\section{Provas de Conhecimento}

\begin{frame}{O que é uma Prova de Conhecimento?}
    
    É um protocolo computacional entre duas partes:
    \begin{itemize}
        \item \textbf{Provador (P):} A parte que alega conhecer uma informação.
        \item \textbf{Verificador (V):} A parte que valida a alegação.
    \end{itemize}

    \vspace{0.5cm}
    Satisfazendo as seguintes propriedades:
    
    \begin{itemize}
        \item \textbf{Completude:} Se P é honesto, V sempre aceitará a prova.
        \item \textbf{Solidez:} Se P é desonesto, V só aceitará a prova com uma probabilidade negligenciável.
    \end{itemize}
\end{frame}

\begin{frame}{Formalizando uma prova de conhecimento}
    \begin{block}{1. "Estar convencido"}
        \begin{itemize}
            \item P e V são modelados como máquinas de Turing interativas.
            %\item Formalmente, é definida uma relação binária $R \subseteq \{0,1\}^{*} \times \{0,1\}^{*}$.
            \item São definidos o parâmetro público $x$ e a testemunha privada $w$.
            \item V é "convencido" quando chega em seu estado de aceitação.
        \end{itemize} 
    \end{block}

    \begin{block}{2. "Saber algo"}
        \begin{itemize}
            \item Se P conhece uma solução válida, então ela pode ser extraída de P.
            \item \textbf{Extrator de conhecimento:} Dispositivo hipotético capaz de extrair $w$ de P.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{O que é uma Prova de Conhecimento Zero?}
\begin{itemize}
    \item A propriedade de \textbf{conhecimento zero} garante que o verificador seja convencido sem revelar nenhuma informação adicional além da veracidade dessa afirmação
    \item É formalmente definido em termos de um \textbf{simulador}: uma máquina que pode gerar uma prova
“falsa” sem ter acesso à testemunha real do provador. Se a prova gerada pelo provador real
for computacionalmente indistinguível da prova gerada pelo simulador, então o verificador não
aprendeu nada além da verdade da afirmação. (A transcrição da conversa é trivial que um simulador também pode gerá-la)
  \end{itemize}
\end{frame}

\begin{frame}{Exemplo Interativo: Coloração de Grafos}
    \begin{itemize}
        \item \textbf{Objetivo:} O Provador (P) quer provar ao Verificador (V) que conhece uma coloração de três cores válida para um grafo $G$, sem revelar tal coloração.
        \item \textbf{Protocolo:}
        \begin{enumerate}
            \item \textbf{Compromisso:} P permuta aleatoriamente as cores ($\pi$), criptografa a cor de cada vértice ($F_v = f(\pi(\phi(v)), r_v)$) e envia todos os $F_v$ para V.
            \item \textbf{Desafio:} V escolhe uma aresta aleatória $(u, v)$ e a envia para P.
            \item \textbf{Resposta:} P revela as cores permutadas $\pi(\phi(u))$, $\pi(\phi(v))$ e as chaves de criptografia $r_u, r_v$.
            \item \textbf{Verificação:} V checa se as chaves abrem os compromissos $F_u, F_v$ e se $\pi(\phi(u)) \neq \pi(\phi(v))$.
        \end{enumerate}
        \item O processo é repetido $m^2$ vezes para garantir a solidez.
    \end{itemize}
\end{frame}

\begin{frame}{Propriedades da Prova Interativa}
    \begin{itemize}
        \item \textbf{Completude:} Se P conhece a coloração e segue o protocolo, V sempre aceitará a prova.
        \item \textbf{Solidez:} Se P não conhece a coloração, V irá rejeitar com alta probabilidade.
        \item \textbf{Conhecimento Zero:} V não aprende nada sobre a coloração. A permutação aleatória $\pi$ a cada rodada garante que as cores reveladas não tenham correlação com a coloração original de P.
    \end{itemize}
    \pause
    \textbf{Problema:} Este protocolo é \textbf{interativo}. Requer múltiplas rodadas de comunicação e é modelado especificamente para um único problema.
\end{frame}

\section{zk-SNARKs}

\begin{frame}{O que é um zk-SNARK?}
    Uma classe especial de Prova de Conhecimento Zero:
    \begin{itemize}        
        \item \textbf{S}uccinct (Sucinto):
        \begin{itemize}
            \item A prova é muito pequena (tamanho constante ou logarítmico).
            \item A verificação é muito rápida.
        \end{itemize}
        
        \item \textbf{N}on-interactive (Não-interativo):
        \begin{itemize}
            \item O Provador envia uma única mensagem para o Verificador.
            \item Geralmente requer uma Cerimônia de Confiança inicial.
        \end{itemize}
        
        \item \textbf{AR}gument of \textbf{K}nowledge (Argumento de Conhecimento):
        \begin{itemize}
            \item A solidez é \textit{computacional} (baseada em problemas difíceis, ex: logaritmo discreto) e não estatística.
        \end{itemize}
      
    \end{itemize}
\end{frame}

\begin{frame}{Exemplo de um circuito}
  Uma \textbf{prova de conhecimento} permite que um provador convença um verificador de que conhece um valor $w$ tal que:
  \[
    C(x,w) = 0
  \]
  Onde:
  \begin{itemize}
    \item $C$ é o circuito da condição a ser satisfeita
    \item $x$ é o parâmetro público
    \item $w$ é o valor privado
  \end{itemize}
  A propriedade \textbf{conhecimento zero} garante que o verificador não aprende nada sobre $w$
\end{frame}

\begin{frame}{Pré-processamento do circuito}
  Cerimônia de Confiança sobre o circuito $C(x,w)$:
  \[
    S(C) \rightarrow (S_p, S_v)
  \]
  Um algoritmo que gera:
  \begin{itemize}
    \item Chave de Prova: $S_p$
    \item Chave de Verificação: $S_v$
  \end{itemize}
\end{frame}

\begin{frame}{Processamento de uma prova}
  \begin{figure}[H]
    %\hspace*{-0.75cm}
    \center
    \fontsize{8}{10} \selectfont
    \includesvg[width=10cm]{./Imagens/zk_snark.svg}
  \end{figure}
\end{frame}

\section{Pinocchio}

\section{Groth16}

\section{Autenticação Biométrica}

\begin{frame}{Reconhecimento Facial com Similaridade de Cossenos}
  O reconhecimento facial pode ser modelado como uma tarefa de comparação entre vetores:
  \begin{itemize}
    \item Cada rosto é representado por um vetor de características (\textit{embedding})
    \item Vetores são gerados por redes neurais treinadas para extrair feições únicas
  \end{itemize}
  A comparação é feita utilizando a \textbf{similaridade de cossenos}.
\end{frame}

\begin{frame}{O que é a Similaridade de Cossenos?}
  A \textbf{similaridade de cossenos} mede o ângulo entre dois vetores:
  \[
    \cos(\theta) = \frac{\vec{A} \cdot \vec{B}}{ \|\vec{A}\| \cdot \|\vec{B}\| }
  \]
  \begin{itemize}
    \item Varia entre $-1$ (opostos) e $1$ (iguais)
    \item Se $\cos(\theta) \approx 1$, vetores são semelhantes → rostos parecidos
  \end{itemize}
\end{frame}

\begin{frame}{Autenticação com Similaridade de Cossenos}
  \begin{enumerate}
    \item A imagem de entrada é convertida em vetor $\vec{A}$
    \item Vetor $\vec{B}$ é previamente armazenado durante a etapa de registro
    \item Se $\cos(\vec{A}, \vec{B}) > \tau$, a autenticação é aceita
  \end{enumerate}
  \textbf{Nota:} $\tau$ é um limiar definido com base no modelo de IA (ex: 0.7)
\end{frame}

\begin{frame}{Problemas em Armazenar \textit{Embeddings} Sem Proteção}
  \textit{Embeddings} faciais são representações vetoriais únicas do rosto de uma pessoa. Armazená-las sem proteção apresenta riscos sérios:
  \begin{itemize}
    \item \textbf{Embeddings são identificadores biométricos:} um atacante pode usar \textit{embeddings} roubadas para reconstruir um rosto e se autenticar como outra pessoa
    \item \textbf{Vazamentos são irreversíveis:} diferente de senhas, as representações vetoriais são insubstituíveis
  \end{itemize}
  \pause
  \textbf{Solução:} usar \textbf{provas de conhecimento zero} para provar correspondência sem expor o vetor.
\end{frame}

\begin{frame}{Integração com Provas de Conhecimento Zero}
  O cálculo da similaridade de cosseno pode ser embutido no circuito de prova de conhecimento zero:
  \begin{itemize}
    \item $\cos(\vec{A}, \vec{B}) > \tau$ é o circuito a ser verificado
    \item O limiar de similaridade $\tau$ é o parâmetro público
    \item As \textit{embeddings} faciais representam os valores privados
  \end{itemize}
  Isso permite autenticação facial \textbf{sem revelar} os vetores faciais.
\end{frame}

\begin{frame}{Vantagens do Método Proposto}
  O sistema de autenticação com provas de conhecimento zero traz benefícios significativos:
  \begin{itemize}
    \item \textbf{Privacidade Total:} o verificador não sabe quem é o usuário, apenas verifica se a prova é válida.
    \item \textbf{Resistência a Vazamentos:} nenhum dado biométrico é armazenado no sistema, por isso não há o que ser vazado ou roubado.
  \end{itemize}
\end{frame}

\begin{frame}{Referências}
  \nocite{*}
  \bibliographystyle{plain}
  \bibliography{Referencias}
\end{frame}

%%%
%%% Slide final
%%%
{
\usebackgroundtemplate{\includegraphics[width=\paperwidth]{Imagens/capa.png}}
\begin{frame}[plain]
\vspace{15mm}
\begin{center}
\textcolor{cinza}{
\textbf{\Large{Muito obrigado!}}
}
\end{center}
\end{frame}
}

\end{document}

