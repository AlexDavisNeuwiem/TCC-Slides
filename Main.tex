\documentclass[t]{beamer}
\usepackage[portuges]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[scaled]{helvet}
\usepackage{svg}
\usepackage{xcolor}
\renewcommand{\familydefault}{\sfdefault}

%%%
%%% Define cores
%%%
\definecolor{cinza}{HTML}{75818B}

%%%
%%% Remove a barra de navegação do Beamer
%%%
\setbeamertemplate{navigation symbols}{}

%%%
%%% Margem dos slides
%%%
\setbeamersize{text margin left=10mm,text margin right=5mm} 

%%%
%%% Redefine a fonte do título dos slides
%%%
\setbeamercolor{frametitle}{fg=cinza}
\setbeamerfont{frametitle}{series=\bfseries}
\setbeamerfont{frametitle}{size=\Large}

%%%
%%% Ajusta a posição do título dos slides e início do texto
%%%
\addtobeamertemplate{frametitle}{\vspace*{2mm}}{\vspace*{5mm}}

%%%
%%% Adiciona paginação nos slides
%%%
%%% Caso não queira, basta comentar este bloco inteiro
%%% para ocultar a paginação
%%%
\addtobeamertemplate{navigation symbols}{}{
\usebeamerfont{footline}
\usebeamercolor[fg]{footline}
}
\setbeamercolor{footline}{fg=cinza}
\setbeamerfont{footline}{series=\bfseries}
\setbeamerfont{footline}{size=\tiny}
\setbeamertemplate{footline}{
\usebeamerfont{page number in head}
\usebeamercolor[fg]{page number in head}
\hspace{5mm}
\insertframenumber/\inserttotalframenumber
\vspace{5mm}
}

%%%
%%% Redefine símbolo padrão do itemize
%%%
\setbeamertemplate{itemize items}[default]

%%%
%%% Insere numeração nas figuras
%%%
\setbeamertemplate{caption}[numbered]

%%%
%%% Imagem de fundo a ser usada em todos os slides (exceto
%%% no primeiro e no último)
%%%
\usebackgroundtemplate
{
\includegraphics[width=\paperwidth,height=\paperheight]{Imagens/fundo.png}
}

%%%
%%% Adiciona slide de "Estrutura"
%%%
\AtBeginSection[]{\frame{\frametitle{Estrutura}\tableofcontents
[current]}}

%%%
%%% Define fontes e cores do slide de "Estrutura"
%%%
\setbeamerfont{section in toc}{series=\bfseries}
\setbeamercolor{section in toc}{fg=gray}
\setbeamerfont{section in toc shaded}{series=\mdseries}
\setbeamercolor{section in toc shaded}{fg=gray!01}
\setbeamercolor{subsection in toc}{fg=cinza}
\setbeamercolor{subsection in toc shaded}{fg=gray!60}
\setbeamercolor{subsubsection in toc}{fg=cinza}
\setbeamercolor{subsubsection in toc shaded}{fg=gray!60}

\mode<presentation>
%%%
%%% Início
%%%
\begin{document}

%%%
%%% Slide da capa
%%%
{
\usebackgroundtemplate{\includegraphics[width=\paperwidth]{Imagens/capa.png}}
\begin{frame}[plain]
\vspace{18mm}
%%%
%%% Título da Apresentação
%%%
\begin{flushright}
\textcolor{cinza}{\textbf{\large{
Provas de Conhecimento Zero: Um Estudo sobre zk-SNARKs e sua Aplicação em Sistemas de Autenticação
}}}
\end{flushright}

\vspace{-6mm}
%%%
%%% Nome do autor
%%%
\begin{flushright}
\textcolor{cinza}{\textbf{\scriptsize{
Alex Davis Neuwiem da Silva
}}}
\end{flushright}

\vspace{-7mm}
%%%
%%% Formação | Departamento | Centro
%%%
\begin{flushright}
\textcolor{cinza}{\scriptsize{
Ciências da Computação | INE | CTC
}}
\end{flushright}


\end{frame}
}

%%%
%%% Demais slides (exceto o slide final)
%%%

\begin{frame}{Introdução}
\begin{columns}[c]
\begin{column}{.5\textwidth}
  \textbf{1. Estudo Teórico}
  \begin{itemize}
    \item Realizar uma análise aprofundada dos principais protocolos zk-SNARKs.
    \item Foco em \textbf{Pinocchio} e \textbf{Groth16}.
  \end{itemize}
\end{column}
\begin{column}{.5\textwidth}
\textbf{2. Aplicação Prática}
  \begin{itemize}
    \item Desenvolver de um sistema de autenticação biométrica facial que preserva a privacidade.
    \item Utiliza \textbf{Groth16}.
  \end{itemize}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{O que é uma Prova de Conhecimento Zero?}
    
    É um protocolo computacional entre duas partes:
    \begin{itemize}
        \item \textbf{Provador $P$:} A parte que alega conhecer uma informação.
        \item \textbf{Verificador $V$:} A parte que valida a alegação.
    \end{itemize}

    \vspace{0.5cm}
    Satisfazendo as seguintes propriedades:
    
    \begin{itemize}
        \item \textbf{Completude:} Se $P$ é honesto, $V$ sempre aceitará a prova.
        \item \textbf{Solidez:} Se $P$ é desonesto, $V$ só aceitará a prova com uma probabilidade negligenciável.
        \item \textbf{Conhecimento Zero:} Garante que o verificador seja convencido sem revelar nenhuma informação adicional além da veracidade dessa afirmação.
    \end{itemize}
\end{frame}

\section{zk-SNARKs}

\begin{frame}{O que é um zk-SNARK?}
    Uma classe especial de Prova de Conhecimento Zero:
    \begin{itemize}        
        \item \textbf{S}uccinct (Sucinto):
        \begin{itemize}
            \item O tamanho da prova e tempo de verificação são constantes.
        \end{itemize}
        
        \item \textbf{N}on-interactive (Não-interativo):
        \begin{itemize}
            \item O Provador envia uma única mensagem para o Verificador.
            \item Geralmente requer uma cerimônia inicial.
        \end{itemize}
        
        \item \textbf{AR}gument of \textbf{K}nowledge (Argumento de Conhecimento):
        \begin{itemize}
            \item A solidez é \textit{computacional} (baseada em problemas difíceis, ex: logaritmo discreto) e não estatística.
        \end{itemize}
      
    \end{itemize}
\end{frame}

\begin{frame}{Processamento de uma prova}
  \begin{itemize}
    \item Circuito $C(x,w) = 0$
    \item Pré-Processamento $S(C) \rightarrow (S_p, S_v)$
  \end{itemize}
  \vspace{0.5cm}
  \begin{figure}[H]
    %\hspace*{-0.75cm}
    \center
    \fontsize{8}{10} \selectfont
    \includesvg[width=10cm]{./Imagens/zk_snark.svg}
  \end{figure}
\end{frame}

\section{Groth16}

\begin{frame}{Criptografia Homomórfica}
$\mathbb{G}_1$, $\mathbb{G}_2$, $\mathbb{G}_T$ são grupos de pontos de curva elíptica.
  \begin{itemize}
      \item Emparelhamento $e: \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$
      \item $g_1$ é gerador para $\mathbb{G}_1$
      \item $g_2$ é gerador para $\mathbb{G}_2$
      \item $e(g_1, g_2)$ é o gerador de $\mathbb{G}_T$
  \end{itemize}

\vspace{0.5cm}
Propriedades:
  \begin{itemize}
      \item Dado $s \cdot g_1$ é difícil encontrar $s$
      \item $e(s_1 \cdot g_1, s_2 \cdot g_2) = e(g_1, g_2)^{(s_1 \cdot s_2)}$
  \end{itemize}
\end{frame}

\begin{frame}{Groth16: O Padrão de Eficiência}
  O Groth16 é uma otimização do protocolo Pinocchio, tornando-se o padrão da indústria.
  \begin{block}{Sua principal vantagem é a otimização:}
  \begin{itemize}
    \item Reduz a prova a apenas \textbf{3 elementos}
    \item Reduz a verificação a apenas \textbf{3 emparelhamentos}
  \end{itemize}
  \end{block}
  \begin{block}{É dividido em 4 etapas:}
  \begin{itemize}
    \item Aritmetização
    \item Cerimônia de confiança
    \item Geração da prova
    \item Verificação da prova
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Aritmetização (Circuito Aritmético)}
Transforma a computação em uma representação matemática verificável
\begin{itemize}
    \item Exemplo $x^3 + x + 5 = y$
\end{itemize}

\[
x^3 + x + 5 = y
\quad \rightarrow \quad
\underbrace{
  \begin{aligned}
      v_1 &= x * x \\
      v_2 &= v_1 * x \\
      y &= (v_2 + x + 5) * 1
  \end{aligned}
}_{\text{Restrições}},
\quad \underbrace{w = [1, y, x, v_1, v_2]}_{\text{Vetor testemunha}}
\]
\end{frame}


\begin{frame}{Aritmetização (R1CS)}
Cada restrição $i$ é representada na forma $w \cdot A_i \times w \cdot B_i = w \cdot C_i$
\[
v_1 = x * x \quad \rightarrow \quad
\begin{aligned}
  w \cdot A_1 &= [1, y, x, v_1, v_2] \cdot [0, 0, 1, 0, 0] = x \\
  w \cdot B_1 &= [1, y, x, v_1, v_2] \cdot [0, 0, 1, 0, 0] = x \\
  w \cdot C_1 &= [1, y, x, v_1, v_2] \cdot [0, 0, 0, 1, 0] = v_1
\end{aligned}
\]

Resultado:
\[
\begin{array}{ccc}
  {[0, 0, 1, 0, 0]} & {[0, 0, 1, 0, 0]} & {[0, 0, 0, 1, 0]} \\
  {[0, 0, 0, 1, 0]} & {[0, 0, 1, 0, 0]} & {[0, 0, 0, 0, 1]} \\
  {[5, 0, 1, 0, 1]} & {[1, 0, 0, 0, 0]} & {[0, 1, 0, 0, 0]} \\
    A & B & C \\
    (\text{entrada esq.}) & (\text{entrada dir.}) & (\text{saída})
\end{array}
\]
\end{frame}

\begin{frame}{Aritmetização (QAP)}
Programa Aritmético Quadrático (QAP): Cada coluna das matrizes é transformada em um polinômio.

\begin{columns}[c]
    \begin{column}{0.3\textwidth}
        \[
        \begin{array}{c}
             [1, y, x, v_1, v_2] \\
             \left[ \begin{array}{c c c c c}
                0 & 0 & 0 & 1 & 0 \\
                0 & 0 & 0 & 0 & 1 \\
                0 & 1 & 0 & 0 & 0
            \end{array} \right] \\
             C
        \end{array}
        \]
    \end{column}
    
    \begin{column}{0.4\textwidth}
    \[
    \begin{aligned}
         O_1(x) &= 0 \\
         O_y(x) &= 0.5x^2 - 1.5x + 1 \\
         O_x(x) &= 0 \\
         O_{v_1}(x) &= 0.5x^2 - 2.5x + 3 \\
         O_{v_2}(x) &= -x^2 + 4x - 3
    \end{aligned}
    \]
    \end{column}

    \begin{column}{0.3\textwidth}
    \[
    \begin{array}{c}
    \left[ \begin{array}{r r r}
         0 &  0   & 0 \\
         1 & -1.5 & 0.5 \\
         0 &  0   & 0  \\
         3 & -2.5 & 0.5 \\
        -3 &  4   & -1 
    \end{array} \right] \\
    O(x)
    \end{array}
    \]
    \end{column}
\end{columns}
\end{frame}

\begin{frame}{Aritmetização (QAP)}
Polinômios resultantes do QAP:
\vspace{0.5cm}

\begin{columns}[c]
    \begin{column}{0.33\textwidth}
    \centering $L(x)$
     \[
    \left[ \begin{array}{r r r}
       5 & -7.5 & 2.5 \\
       0 & 0 & 0 \\
       4 & -4   & 1  \\
      -3 & 4 & -1  \\
       1 & -1.5 & 0.5
    \end{array} \right]
    \]
    \end{column}
    
    \begin{column}{0.33\textwidth}
    \centering $R(x)$
     \[
    \left[ \begin{array}{r r r}
         1 & -1.5 & 0.5 \\
         0 & 0    & 0 \\
         0 & 1.5  & -0.5 \\
         0 & 0    & 0 \\
         0 & 0    & 0
    \end{array} \right]
    \]
    \end{column}

    \begin{column}{0.33\textwidth}
    \centering $O(x)$
    \[
    \left[ \begin{array}{r r r}
         0 &  0   & 0 \\
         1 & -1.5 & 0.5 \\
         0 &  0   & 0  \\
         3 & -2.5 & 0.5 \\
        -3 &  4   & -1 
    \end{array} \right]
    \]
    \end{column}
\end{columns}
\end{frame}

\begin{frame}{Aritmetização}

Finalmente chegamos a uma fórmula simples:
\[
  w \cdot L(x) \times w \cdot R(x) = w \cdot O(x)
\]
    
Para uma entrada $w$ válida, a equação se sustenta:
\[
  P(x) = w \cdot L(x) \times w \cdot R(x) - w \cdot O(x) = H(x) \times T(x)
\]

Em nosso exemplo, temos:
\[
  T(x) = (x-1)(x-2)(x-3)
\]

Note que L(x), R(x), O(x) e T(x) são públicos e apenas um provador honesto pode gerar P(x) e H(x).
\end{frame}

\begin{frame}{A Otimização Chave do Groth16}
A equação é reestruturada usando os valores aleatórios $\alpha$ e $\beta$:
\begin{align*}
( &\alpha + w \cdot L(x)) \times (\beta + w \cdot R(x)) = \\
&\alpha \cdot \beta + \alpha \cdot w \cdot R(x) + \beta \cdot w \cdot L(x) + w \cdot O(\tau) + H(\tau) \cdot T(\tau)
\end{align*}

Verificação no ponto $\tau$, pelo lema de Schwartz-Zippel:
\begin{align*}
& e(\underbrace{ \left( \alpha + w \cdot L(\tau) \right) \cdot g_1 }_{A},
\underbrace{ \left( \beta + w \cdot R(\tau) \right) \cdot g_2 }_{B}) = \\
& \underbrace{e(\alpha \cdot g_1, \beta \cdot g_2)}_{D} \cdot \\
& e(\underbrace{\left( \alpha \cdot w \cdot R(\tau) + \beta \cdot w \cdot L(\tau) + w \cdot O(\tau) + H(\tau) \cdot T(\tau) \right)}_{C}, g_2)
\end{align*}

\end{frame}

\begin{frame}{Cerimônia de Confiança}
  O Groth16 usa uma cerimônia de confiança \textbf{específica do circuito} para gerar parâmetros públicos.
  \begin{itemize}
    \item Baseia-se em valores aleatórios secretos (``lixo tóxico''): $\alpha, \beta, \tau, \gamma, \delta$.
    \item Estes valores devem ser descartados. Se guardados, podem criar provas falsas.
    \item A cerimônia gera a Chave de Prova ($S_p$) e a Chave de Verificação ($S_v$).
  \end{itemize}
\end{frame}

\begin{frame}{Geração da Prova}
Para garantir o \textbf{conhecimento zero}, o provador mascara os componentes da prova, gerando dois escalares aleatórios, $r$ e $s$.
\begin{align*}
A &= \textcolor{red}{\alpha \cdot g_1} + \sum_{i=0}^{m-1} w_i \cdot \textcolor{red}{L_i(\tau) \cdot g_1} + r \cdot \textcolor{red}{\delta \cdot g_1} \\
B' &= \textcolor{red}{\beta \cdot g_1} + \sum_{i=0}^{m-1} w_i \cdot \textcolor{red}{R_i(\tau) \cdot g_1} + s \cdot \textcolor{red}{\delta \cdot g_1} \\
B &= \textcolor{red}{\beta \cdot g_2} + \sum_{i=0}^{m-1} w_i \cdot \textcolor{red}{R_i(\tau) \cdot g_2} + s \cdot \textcolor{red}{\delta \cdot g_2} \\
C &= \sum_{i=l}^{m-1} w_i \cdot \textcolor{red}{\sigma_i} + H(\tau) \cdot \textcolor{red}{T(\tau)} + s \cdot A + r \cdot B' - r \cdot s \cdot \textcolor{red}{\delta \cdot g_1} 
\end{align*}
\end{frame}

\begin{frame}{Verificação da Prova}
Primeiramente, o verificador utiliza a parte pública da testemunha e $\sigma_0, \dots, \sigma_{l-1}$ para calcular $W$:
\[
W = \sum_{i=0}^{l - 1} w_i \cdot \textcolor{blue}{\sigma_i}
\]

O verificador então insere a prova $\pi$, sua parte calculada $W$, e os elementos da chave de verificação na equação:
\[
e(\textcolor{red}{A}, \textcolor{red}{B}) = e(\textcolor{blue}{\alpha \cdot g_1}, \textcolor{blue}{\beta \cdot g_2}) \cdot e(W, \textcolor{blue}{\gamma \cdot g_2}) \cdot e(\textcolor{red}{C}, \textcolor{blue}{\delta \cdot g_2})
\]
\end{frame}

\section{Autenticação Biométrica}

\begin{frame}{Reconhecimento Facial com Similaridade de Cossenos}
  O reconhecimento facial pode ser modelado como uma tarefa de comparação entre vetores:
  \begin{itemize}
    \item Cada rosto é representado por um vetor de características (\textit{embedding})
    \item Vetores são gerados por redes neurais treinadas para extrair feições únicas
  \end{itemize}
  A comparação é feita utilizando a \textbf{similaridade de cossenos}.
\end{frame}

\begin{frame}{O que é a Similaridade de Cossenos?}
  A \textbf{similaridade de cossenos} mede o ângulo entre dois vetores:
  \[
    \cos(\theta) = \frac{\vec{A} \cdot \vec{B}}{ \|\vec{A}\| \cdot \|\vec{B}\| }
  \]
  \begin{itemize}
    \item Varia entre $-1$ (opostos) e $1$ (iguais)
    \item Se $\cos(\theta) \approx 1$, vetores são semelhantes → rostos parecidos
  \end{itemize}
\end{frame}

\begin{frame}{Autenticação com Similaridade de Cossenos}
  \begin{enumerate}
    \item A imagem de entrada é convertida em vetor $\vec{A}$
    \item Vetor $\vec{B}$ é previamente armazenado durante a etapa de registro
    \item Se $\cos(\vec{A}, \vec{B}) > \tau$, a autenticação é aceita
  \end{enumerate}
  \textbf{Nota:} $\tau$ é um limiar definido com base no modelo de IA (ex: 0.7)
\end{frame}

\begin{frame}{Problemas em Armazenar \textit{Embeddings} Sem Proteção}
  \textit{Embeddings} faciais são representações vetoriais únicas do rosto de uma pessoa. Armazená-las sem proteção apresenta riscos sérios:
  \begin{itemize}
    \item \textbf{Embeddings são identificadores biométricos:} um atacante pode usar \textit{embeddings} roubadas para reconstruir um rosto e se autenticar como outra pessoa
    \item \textbf{Vazamentos são irreversíveis:} diferente de senhas, as representações vetoriais são insubstituíveis
  \end{itemize}
  \pause
  \textbf{Solução:} usar \textbf{provas de conhecimento zero} para provar correspondência sem expor o vetor.
\end{frame}

\begin{frame}{Integração com Provas de Conhecimento Zero}
  O cálculo da similaridade de cosseno pode ser embutido no circuito de prova de conhecimento zero:
  \begin{itemize}
    \item $\cos(\vec{A}, \vec{B}) > \tau$ é o circuito a ser verificado
    \item O limiar de similaridade $\tau$ é o parâmetro público
    \item As \textit{embeddings} faciais representam os valores privados
  \end{itemize}
  Isso permite autenticação facial \textbf{sem revelar} os vetores faciais.
\end{frame}

\begin{frame}{Vantagens do Método Proposto}
  O sistema de autenticação com provas de conhecimento zero traz benefícios significativos:
  \begin{itemize}
    \item \textbf{Privacidade Total:} o verificador não sabe quem é o usuário, apenas verifica se a prova é válida.
    \item \textbf{Resistência a Vazamentos:} nenhum dado biométrico é armazenado no sistema, por isso não há o que ser vazado ou roubado.
  \end{itemize}
\end{frame}

\begin{frame}{Fase de registro}
\begin{enumerate}
  \item O Usuário $U$ inicia o processo de registro enviando sua face $f_{reg}$ para o Modelo de IA $M$:
\[
  M \xleftarrow{f_{reg}} U
\]
  \item $M$ extrai a \textit{embedding} $e_{reg}$ de $f_{reg}$ ao calcular:
\[
  e_{reg} := Emb(f_{reg})
\]
  \item $M$ envia a \textit{embedding} $e_{reg}$ para $U$:
\[
  M \xrightarrow{e_{reg}} U
\]
  \item $U$ gera uma chave simétrica $k$ e criptografa sua \textit{embedding}:
\[
  c_{reg} := Enc_k(e_{reg})
\]
\end{enumerate}
\end{frame}

\begin{frame}{Fase de registro}
\begin{enumerate}
  \item $U$ envia a \textit{embedding} criptografada $c_{reg}$ para o Servidor $S$:
\[
  U \xrightarrow{c_{reg}} S
\]
  \item $S$ armazena a \textit{embedding} criptografada $c_{reg}$ e gera um identificador único $id$:
\[
  id := GenId()
\]
  \item $S$ envia o identificador $id$ para $U$:
\[
  U \xleftarrow{id} S
\]
\end{enumerate}
\end{frame}

\begin{frame}{Fase de registro}
  \begin{figure}[H]
    \vspace{-1cm}
    %\hspace*{-0.75cm}
    \center
    \fontsize{4}{10} \selectfont
    \includesvg[width=6cm]{./Imagens/registro.svg}
  \end{figure}
\end{frame}

\begin{frame}{Fase de autenticação}
\begin{enumerate}
  \item O Usuário $U$ inicia o processo de autenticação ao enviar o identificador $id$ ao Servidor $S$:
\[
  U \xrightarrow{id} S
\]
  \item $S$ envia a chave de prova $S_p$ e uma cópia da \textit{embedding} criptografada $c_{reg}$, que é correspondente ao $id$ recebido, a $U$:
\[
  U \xleftarrow{S_p, c_{reg}} S
\]
  \item $U$ descriptografa a \textit{embedding} $e_{reg}$ recebida ao calcular:
\[
  e_{reg} := Dec_k(c_{reg})
\]
\end{enumerate}
\end{frame}

\begin{frame}{Fase de autenticação}
\begin{enumerate}
  \item $U$ solicita a prova do protocolo zk-SNARK ao enviar a chave de prova $S_p$, a \textit{embedding} recém descriptografada $e_{reg}$ e uma nova captura de sua face $f_{cur}$ para o Modelo de IA $M$:
\[
  M \xleftarrow{S_p, e_{reg}, f_{cur}} U
\]
  \item $M$ extrai a \textit{embedding} $e_{cur}$ a partir da face $f_{cur}$ e gera a prova zk-SNARK $\pi$ ao computar:
\[
  e_{cur} := Emb(f_{cur})
\]
\[
  \pi := Prove(S_p, x = \tau, w = (e_{cur}, e_{reg}))
\]
  \item $M$ envia a prova zk-SNARK $\pi$ a $U$:
\[
  M \xrightarrow{\pi} U
\]
\end{enumerate}
\end{frame}

\begin{frame}{Fase de autenticação}
\begin{enumerate}
  \item $U$ envia a prova zk-SNARK $\pi$ a $S$:
\[
  U \xrightarrow{\pi} S
\]
  \item $S$ verifica a validade da prova $\pi$ ao calcular:
\[
  r := Verify(S_v, x = \tau, \pi)
\]
  \item $S$ envia o veredito da autenticação $r$ para $U$:
\[
  U \xleftarrow{r} S
\]
\end{enumerate}
\end{frame}

\begin{frame}{Fase de autenticação}
  \begin{figure}[H]
    \vspace{-1cm}
    %\hspace*{-0.75cm}
    \center
    \fontsize{4}{10} \selectfont
    \includesvg[width=6cm]{./Imagens/autenticacao.svg}
  \end{figure}
\end{frame}

%%%
%%% Slide final
%%%
{
\usebackgroundtemplate{\includegraphics[width=\paperwidth]{Imagens/capa.png}}
\begin{frame}[plain]
\vspace{15mm}
\begin{center}
\textcolor{cinza}{
\textbf{\Large{Muito obrigado!}}
}
\end{center}
\end{frame}
}

\end{document}

